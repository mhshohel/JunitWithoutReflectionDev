/**
 *
 * @ProjectName JunitTestWithActualLib
 *
 * @PackageName tools.code.gen
 *
 * @FileName OutputCodeProperties.java
 * 
 * @FileCreated Jan 4, 2013
 *
 * @Author MD. SHOHEL SHAMIM
 *
 * @CivicRegistration 19841201-0533
 *
 * MSc. in Software Technology
 *
 * Linnaeus University, Växjö, Sweden
 *
 */
package tools.code.gen;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;

/**
 * This class has list of properties for different Junit annotations and object;
 * Each properties contains different output code according to JUnit
 * annotations;
 */
public class OutputCodeProperties {
    /*
     * after: Contains all methods with object name and required parameters that
     * is annotated by @After
     */
    private List<String> after = new ArrayList<String>();
    /*
     * afterClass: Contains all methods with object name and required parameters
     * that is annotated by @AfterClass
     */
    private List<String> afterClass = new ArrayList<String>();
    /*
     * before: Contains all methods with object name and required parameters
     * that is annotated by @Before
     */
    private List<String> before = new ArrayList<String>();
    /*
     * beforeClass: Contains all methods with object name and required
     * parameters that is annotated by @BeforeClass
     */
    private List<String> beforeClass = new ArrayList<String>();
    /* Entry Class */
    private Class<?> clas;
    /* Simple class name */
    private String className;
    /*
     * List of Rule Properties. Code generates by calling object or value from
     * each properties.
     */
    private List<RuleAndClassRuleProperties> classRules = new ArrayList<RuleAndClassRuleProperties>();
    /* Additional extension to avoid duplicate object name. */
    private int counter = 0;
    /* Object name with "." sign */
    private String object;
    /* Object name without "." sign */
    private String objectName;
    /*
     * List of ClassRule Properties. Code generates by calling object or value
     * from each properties.
     */
    private List<RuleAndClassRuleProperties> rules = new ArrayList<RuleAndClassRuleProperties>();
    /*
     * testMethods: Contains all methods with object name and required
     * parameters that is annotated by @Test
     */
    private HashMap<Integer, TestProperties> testMethods = new HashMap<Integer, TestProperties>();
    /*
     * theoryMethods: Contains all methods by object name and required
     * parameters that is annotated by @Theory; including @DataPoint,
     * 
     * @DataPoints, @ParameterSuppliedBy, @TestedOn
     */
    private HashMap<Integer, TheoryMethodContainer> theoryMethods = new HashMap<Integer, TheoryMethodContainer>();

    /**
     * <li><strong><i>addAfter</i></strong></li>
     * 
     * <pre>
     * public void addAfter(String name)
     * </pre>
     * 
     * <p>
     * Add methods that is generated by After annotation
     * </p>
     * 
     * @param name
     *            - method name.
     * 
     * @author Shohel Shamim
     */
    public void addAfter(String name) {
	if (!this.after.contains(name)) {
	    this.after.add(name);
	}
    }

    /**
     * <li><strong><i>addAfterClass</i></strong></li>
     * 
     * <pre>
     * public void addAfterClass(String name)
     * </pre>
     * 
     * <p>
     * Add methods that is generated by AfterClass annotation
     * </p>
     * 
     * @param name
     *            - method name.
     * 
     * @author Shohel Shamim
     */
    public void addAfterClass(String name) {
	if (!this.afterClass.contains(name)) {
	    this.afterClass.add(name);
	}
    }

    /**
     * <li><strong><i>addBefore</i></strong></li>
     * 
     * <pre>
     * public void addBefore(String name)
     * </pre>
     * 
     * <p>
     * Add methods that is generated by Before annotation
     * </p>
     * 
     * @param name
     *            - method name.
     * 
     * @author Shohel Shamim
     */
    public void addBefore(String name) {
	if (!this.before.contains(name)) {
	    this.before.add(name);
	}
    }

    /**
     * <li><strong><i>addBeforeClass</i></strong></li>
     * 
     * <pre>
     * public void addBeforeClass(String name)
     * </pre>
     * 
     * <p>
     * Add methods that is generated by BeforeClass annotation.
     * </p>
     * 
     * @param name
     *            - method name.
     * 
     * @author Shohel Shamim
     */
    public void addBeforeClass(String name) {
	if (!this.beforeClass.contains(name)) {
	    this.beforeClass.add(name);
	}
    }

    /**
     * <li><strong><i>RuleAndClassRuleProperties</i></strong></li>
     * 
     * <pre>
     * public RuleAndClassRuleProperties addClassRule(Class<?> clz, Field field)
     * </pre>
     * 
     * <p>
     * Field that is annotated by ClassRule. That field should be static.
     * </p>
     * 
     * @param clz
     *            - a class name with .class extension or Class Type
     * @param field
     *            - a Field Type.
     * 
     * @return RuleAndClassRuleProperties
     * 
     * @author Shohel Shamim
     */
    public RuleAndClassRuleProperties addClassRule(Class<?> clz, Field field) {
	RuleAndClassRuleProperties racrp = null;
	String object = clz.getSimpleName();
	if (this.classRules.isEmpty()) {
	    racrp = new RuleAndClassRuleProperties(clz, field, object, "");
	    this.classRules.add(racrp);
	} else {
	    // verify whether same filed is in the list or not.
	    boolean isAlreadyInList = false;
	    for (RuleAndClassRuleProperties rc : this.classRules) {
		if (rc.getField().getName().equalsIgnoreCase(field.getName())) {
		    isAlreadyInList = true;
		    break;
		}
	    }
	    // no duplicate filed is allowed.
	    if (!isAlreadyInList) {
		racrp = new RuleAndClassRuleProperties(clz, field, object, "");
		this.classRules.add(racrp);
	    }
	}
	return racrp;
    }

    /**
     * <li><strong><i>addRule</i></strong></li>
     * 
     * <pre>
     * public RuleAndClassRuleProperties addRule(GenerateCode generateCode,
     * 	    String outputClassName, Class<?> clz, Field field,
     * 	    FieldsProperty fieldsProperty, String objectName)
     * </pre>
     * 
     * <p>
     * Field that is annotated by Rule. That field should not be static
     * according to the Junit Rules. Object of generateCode need to pass so that
     * RuleAndClassRuleProperties can get the required properties from that.
     * outputClassName required to create the object name for the field. clz is
     * the current Class and the field is that which is annotated by Rule.
     * fieldsProperty object required to provide required properties to
     * RuleAndClassRuleProperties.
     * </p>
     * 
     * @param generateCode
     *            - object of generateCode.
     * @param outputClassName
     *            - class name as String format.
     * @param clz
     *            - a ClassType.
     * @param field
     *            - a Field Type.
     * @param fieldsProperty
     *            - object of fieldsProperty.
     * @param objectName
     *            - object name.
     * 
     * @return RuleAndClassRuleProperties
     * 
     * @author Shohel Shamim
     */
    public RuleAndClassRuleProperties addRule(GenerateCode generateCode,
	    String outputClassName, Class<?> clz, Field field,
	    FieldsProperty fieldsProperty, String objectName) {
	RuleAndClassRuleProperties racrp = null;
	if (fieldsProperty != null) {
	    String object = (objectName + "_" + generateCode.counter++).trim();
	    String staticObject = clz.getSimpleName() + " " + object;
	    object = outputClassName + "." + object;
	    String assignValue = fieldsProperty.getFieldAssignValue();
	    generateCode.addStaticFieldsForRules(staticObject);
	    if (this.rules.isEmpty()) {
		racrp = new RuleAndClassRuleProperties(clz, field, object,
			assignValue);
		this.rules.add(racrp);
	    } else {
		// verify is field whether filed is already in the list or not.
		boolean isAlreadyInList = false;
		for (RuleAndClassRuleProperties rc : this.rules) {
		    if (rc.getField().getName()
			    .equalsIgnoreCase(field.getName())) {
			isAlreadyInList = true;
			break;
		    }
		}
		// no duplicate field is allowed
		if (!isAlreadyInList) {
		    racrp = new RuleAndClassRuleProperties(clz, field, object,
			    assignValue);
		    this.rules.add(racrp);
		}
	    }
	}
	return racrp;
    }

    /**
     * <li><strong><i>addTestMethod</i></strong></li>
     * 
     * <pre>
     * public void addTestMethod(TestProperties testProperties)
     * </pre>
     * 
     * <p>
     * Add methods that is generated by annotation Test.
     * </p>
     * 
     * @param testProperties
     *            - Test method properties.
     * 
     * @author Shohel Shamim
     */
    public void addTestMethod(TestProperties testProperties) {
	if (!testProperties.contains(this.testMethods.values())) {
	    this.testMethods.put(this.counter++, testProperties);
	}
    }

    /**
     * <li><strong><i>addTheoryMethods</i></strong></li>
     * 
     * <pre>
     * public void addTheoryMethods(ClassRecords classRecords, Method method, String generatedMethod)
     * </pre>
     * 
     * <p>
     * Add methods that is generated by annotations DataPoint or DataPoints,
     * TestedOn, ParameterSuppliedBy. It will store both actual method and
     * generated method for output. If same method name found in the list then
     * it will check whether actual methods are same or not (including their
     * parameters). If they are same then it will give the access to add
     * generated method otherwise not. New element will be created if name not
     * match.
     * </p>
     * 
     * @param classRecords
     *            - object of ClassRecords.
     * @param method
     *            - a Method Type.
     * @param generatedMethod
     *            - name of generated method.
     * 
     * @author Shohel Shamim
     */
    public void addTheoryMethods(ClassRecords classRecords, Method method,
	    String generatedMethod) {
	boolean isParamSame = false;
	TheoryMethodContainer theoryMethodContainer = null;
	// traverse all theory methods. duplicate is not allowed.
	for (TheoryMethodContainer dpmc : this.theoryMethods.values()) {
	    // compare name
	    if (dpmc.getMethod().getName().equalsIgnoreCase(method.getName())) {
		// compare length, because method can be overloaded
		if ((dpmc.getMethod().getParameterTypes().length == method
			.getParameterTypes().length)) {
		    if (method.getParameterTypes().length == 0) {
			isParamSame = true;
		    } else {
			for (int i = 0; i < dpmc.getMethod()
				.getParameterTypes().length; i++) {
			    if ((dpmc.getMethod().getParameterTypes()[i]
				    .equals(method.getParameterTypes()[i]))) {
				isParamSame = true;
			    } else {
				isParamSame = false;
				break;
			    }
			}
		    }
		}
	    }
	    if (isParamSame) {
		theoryMethodContainer = dpmc;
		break;
	    }
	}
	if (theoryMethodContainer != null) {
	    if (theoryMethodContainer.getMethod().equals(method)) {
		boolean matched = false;
		for (String tmc : theoryMethodContainer.getTheoryMethodList()) {
		    if (tmc.equalsIgnoreCase(generatedMethod)) {
			matched = true;
			break;
		    }
		}
		if (!matched) {
		    theoryMethodContainer.addMethod(generatedMethod);
		}
	    }
	}
	// theoryMethodContainer is null or methods parameters are not same
	// then create new theoryMethodContainer
	if (theoryMethodContainer == null || (!isParamSame)) {
	    theoryMethodContainer = new TheoryMethodContainer(
		    classRecords.getClass(), method);
	    theoryMethodContainer.addMethod(generatedMethod);
	    this.theoryMethods.put(this.counter++, theoryMethodContainer);
	}
    }

    /**
     * <li><strong><i>getAfter</i></strong></li>
     * 
     * <pre>
     * public List<String> getAfter()
     * </pre>
     * 
     * <p>
     * Return methods those are generated from annotation After
     * </p>
     * 
     * @return List<String> - return List of methods.
     * 
     * @author Shohel Shamim
     */
    public List<String> getAfter() {
	return this.after;
    }

    /**
     * <li><strong><i>getAfterClass</i></strong></li>
     * 
     * <pre>
     * public List<String> getAfterClass()
     * </pre>
     * 
     * <p>
     * Return methods those are generated from AfterClass.
     * </p>
     * 
     * @return List<String> - return List of methods.
     * 
     * @author Shohel Shamim
     */
    public List<String> getAfterClass() {
	return this.afterClass;
    }

    /**
     * <li><strong><i>getBefore</i></strong></li>
     * 
     * <pre>
     * public List<String> getBefore()
     * </pre>
     * 
     * <p>
     * Return methods that is generated from annotation Before in reverse order
     * to get exact output of Junit
     * </p>
     * 
     * @return List<string> - return list of methods.
     * 
     * @author Shohel Shamim
     */
    public List<String> getBefore() {
	// Reverse order of @Before annotated method
	List<String> bef = new ArrayList<String>();
	for (int i = this.before.size() - 1; i >= 0; i--) {
	    bef.add(this.before.get(i));
	}
	return bef;
    }

    /**
     * <li><strong><i>getBeforeClass</i></strong></li>
     * 
     * <pre>
     * public List<String> getBeforeClass()
     * </pre>
     * 
     * <p>
     * Return methods those are (is) generated from annotation BeforeClass in
     * reverse order to get exact output of Junit
     * </p>
     * 
     * @return List<string> - return list of methods.
     * 
     * @author Shohel Shamim
     */
    public List<String> getBeforeClass() {
	// Reverse order of @BeforeClass annotated method
	List<String> befClass = new ArrayList<String>();
	for (int i = this.beforeClass.size() - 1; i >= 0; i--) {
	    befClass.add(this.beforeClass.get(i));
	}
	return befClass;
    }

    /**
     * <li><strong><i>getClassName</i></strong></li>
     * 
     * <pre>
     * public String getClassName()
     * </pre>
     * 
     * <p>
     * Return Simple name of class
     * </p>
     * 
     * @return String - class name.
     * 
     * @author Shohel Shamim
     */
    public String getClassName() {
	return this.className;
    }

    /**
     * <li><strong><i>getClassRules</i></strong></li>
     * 
     * <pre>
     * public List<RuleAndClassRuleProperties> getClassRules()
     * </pre>
     * 
     * <p>
     * Return methods those are generated from annotation ClassRule.
     * </p>
     * 
     * @return List<RuleAndClassRuleProperties> - List of
     *         RuleAndClassRuleProperties object.
     * 
     * @author Shohel Shamim
     */
    public List<RuleAndClassRuleProperties> getClassRules() {
	return this.classRules;
    }

    /**
     * <li><strong><i>getClassRulesBeforeTest</i></strong></li>
     * 
     * <pre>
     * public List<RuleAndClassRuleProperties> getClassRulesBeforeTest()
     * </pre>
     * 
     * <p>
     * Return methods those are generated from annotation ClassRule.
     * </p>
     * 
     * @return List<RuleAndClassRuleProperties> - return list of
     *         RuleAndClassRuleProperties object.
     * 
     * @author Shohel Shamim
     */
    public List<RuleAndClassRuleProperties> getClassRulesBeforeTest() {
	List<RuleAndClassRuleProperties> befClassRule = new ArrayList<RuleAndClassRuleProperties>();
	for (int i = this.classRules.size() - 1; i >= 0; i--) {
	    befClassRule.add(this.classRules.get(i));
	}
	return befClassRule;
    }

    /**
     * <li><strong><i>getClasz</i></strong></li>
     * 
     * <pre>
     * public Class<?> getClasz()
     * </pre>
     * 
     * <p>
     * Get Original Class.
     * </p>
     * 
     * @return Class<?> - return Class type.
     * 
     * @author Shohel Shamim
     */
    public Class<?> getClasz() {
	return this.clas;
    }

    /**
     * <li><strong><i>getObject</i></strong></li>
     * 
     * <pre>
     * public String getObject()
     * </pre>
     * 
     * <p>
     * Return object name with "." sign.
     * </p>
     * 
     * @return String - object name.
     * 
     * @author Shohel Shamim
     */
    public String getObject() {
	return this.object;
    }

    /**
     * <li><strong><i>getObjectWithDotSign</i></strong></li>
     * 
     * <pre>
     * public String getObjectWithDotSign()
     * </pre>
     * 
     * <p>
     * Return object name without "." sign.
     * </p>
     * 
     * @return String - object name with "." sign.
     * 
     * @author Shohel Shamim
     */
    public String getObjectWithDotSign() {
	return this.objectName;
    }

    /**
     * <li><strong><i>getRules</i></strong></li>
     * 
     * <pre>
     * public List<RuleAndClassRuleProperties> getRules()
     * </pre>
     * 
     * <p>
     * Return methods those are generated by annotation Rule
     * </p>
     * 
     * @return list<RuleAndClassRuleProperties> - return list of
     *         RuleAndClassRuleProperties object.
     * 
     * @author Shohel Shamim
     */
    public List<RuleAndClassRuleProperties> getRules() {
	return this.rules;
    }

    /**
     * <li><strong><i>getRulesBeforeTest</i></strong></li>
     * 
     * <pre>
     * public List<RuleAndClassRuleProperties> getRulesBeforeTest()
     * </pre>
     * 
     * <p>
     * Return methods that is generated by annotation Rule in reverse order.
     * </p>
     * 
     * @return List<RuleAndClassRuleProperties> - return list of
     *         RuleAndClassRuleProperties objects reverse order.
     * 
     * @author Shohel Shamim
     */
    public List<RuleAndClassRuleProperties> getRulesBeforeTest() {
	// Reverse order of @Rule annotated field
	List<RuleAndClassRuleProperties> befClassRule = new ArrayList<RuleAndClassRuleProperties>();
	for (int i = this.rules.size() - 1; i >= 0; i--) {
	    befClassRule.add(this.rules.get(i));
	}
	return befClassRule;
    }

    /**
     * <li><strong><i>getTestMethods</i></strong></li>
     * 
     * <pre>
     * public Collection<String> getTestMethods()
     * </pre>
     * 
     * <p>
     * Return methods those are generated from annotation Test
     * </p>
     * 
     * @return Collection<String> - return methods.
     * 
     * @author Shohel Shamim
     */
    public Collection<TestProperties> getTestMethods() {
	return this.testMethods.values();
    }

    /**
     * <li><strong><i>getTheoryMethods</i></strong></li>
     * 
     * <pre>
     * public List<String> getTheoryMethods()
     * </pre>
     * 
     * <p>
     * Return methods those are generated from annotation DataPoint or
     * DataPoints.
     * </p>
     * 
     * @return List<String> - return list of Theory Methods.
     * 
     * @author Shohel Shamim
     */
    public List<String> getTheoryMethods() {
	List<String> methods = new ArrayList<String>();
	for (TheoryMethodContainer dpmc : this.theoryMethods.values()) {
	    methods.addAll(dpmc.getTheoryMethodList());
	}
	return methods;
    }

    /**
     * <li><strong><i>setClassName</i></strong></li>
     * 
     * <pre>
     * public void setClassName(String className)
     * </pre>
     * 
     * <p>
     * Set Simple class name.
     * </p>
     * 
     * @param className
     *            - class simple name.
     * 
     * @author Shohel Shamim
     */
    public void setClassName(String className) {
	this.className = className;
    }

    /**
     * <li><strong><i>setClasz</i></strong></li>
     * 
     * <pre>
     * public void setClasz(Class<?> clas)
     * </pre>
     * 
     * <p>
     * Set original class as Class Type.
     * </p>
     * 
     * @param clas
     *            - a class name with .class extension or Class Type
     * 
     * @author Shohel Shamim
     */
    public void setClasz(Class<?> clas) {
	this.clas = clas;
    }

    /**
     * <li><strong><i>setObject</i></strong></li>
     * 
     * <pre>
     * public void setObject(String object)
     * </pre>
     * 
     * <p>
     * Set object with "." sign.
     * </p>
     * 
     * @param object
     *            - a object name.
     * 
     * @author Shohel Shamim
     */
    public void setObject(String object) {
	this.object = object;
    }

    /**
     * <li><strong><i>setObjectName</i></strong></li>
     * 
     * <pre>
     * public void setObjectName(String objectName)
     * </pre>
     * 
     * <p>
     * Set object without "." sign.
     * </p>
     * 
     * @param objectName
     *            - a object name.
     * 
     * @author Shohel Shamim
     */
    public void setObjectName(String objectName) {
	this.objectName = objectName;
    }
}